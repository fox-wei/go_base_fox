# TCP服务实现

遇到问题解决思路：理解问题->技术调研与储备->设计、实现与优化->理解问题(循环过程)。

TCP/IP网络模型，实现两种传输协议(传输层)：TCP和UDP。TCP是面向连接的流协议，为通信两端提供稳定可靠的数据传输服务；UDP是一种无需建立连接就可以发送数据包的方法。基于HTTP的Web编程是针对应用层的网络编程。

可以基于传输层暴露给开发者的编程接口，实现应用层的自定义应用协议。目前传输层暴露的编程接口为套接字(Socket)。**基于Socket编程实现应用层通信业务，是一种常见的网络编程形式。**

问题描述：**实现一个基于TCP的自定义应用层协议的通信服务端。**

输入：是一个基于传输层自定义的应用层协议规范。TCP是面向连接的流协议传输机制，数据无明显边界。TCP自定义应用层常见两种协议：

- **二进制模式**：采用长度字段标识独立数据包的边界。
- **文本模式**：采用特定分隔符标识数据包的边界。

这里采用二进制模式，协议规范如下：

<font color=GoldenRod>表：请求消息包定义</font>
| 序号 |  字符名  |  类型  |  长度  |  描述   |
|----|----|----|----|----|
|  1  |  totalLength  | uint32  | 4 byte| 消息总长度(含自身及后面消息体)|
|  2 | commandID| uint8 | 1 byte|消息或响应类型|
| 3 | ID | String(数字类型) | 8 byte | 消息流水号(顺序累加，步长1,循环使用(一对请求和应用消息的流水号必须相同))|
| 4 | payload | 字节序列 | 任意长度|  消息的有效载荷，应用层需要有效数据|
<br>

<font color=GoldenRod>表：响应消息包定义</font>
| 序号 |  字符名  |  类型  |  长度  |  描述   |
|----|----|----|----|----|
|  1  |  totalLength  | uint32  | 4 byte| 消息总长度(含自身及后面消息体)|
|  2 | commandID| uint8 | 1 byte|消息或响应类型|
| 3 | ID | String(数字类型) | 8 byte | 消息流水号(顺序累加，步长1,循环使用(一对请求和应用消息的流水号必须相同))|
| 4 | result | uint8 | 1 byte|  响应状态(0:正常，1:错误)|

我们的目标是实现一个请求/响应模型通信模型。连接请求由客户端发起，建立连接后，客户端发送请求，服务端接受请求后处理并返回响应。

**所需技术**：

- socket模型
- 网络I/O操作
- 字节操作

socket是传输层给用户提供的编程接口，要先了解socket模型，其次一旦通过socket建立连接后，剩下的是进行网络I/O操作，最后是数据操作，TCP是流协议，要了解字节操作。

**TCP socket模型**

阻塞(Blocking)与非阻塞(Non-Blocking)来描述网络I/O模型，两者的区别是以内核是否等数据全部就绪后，才返回来区分。内核一直等待数据就绪后才返回是阻塞；内核查看就绪状态后，即便没有就绪就返回错误，这是非阻塞。

**Go Socke编程模型**

<font color=#BA55D3>socket监听(listen)和接收连接(accept)</font>

Socket编程的核心在与服务端，服务端的固定套路：Lisen和Accept。